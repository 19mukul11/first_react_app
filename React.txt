**** REACT BASICS ******

ReactJS  is a library of Javascript. Used for developing efficient and fast UI.
Single Page Applications.

Developed and maintained by Facebook.


********* CREATE FIRST REACT APP *****************

CMD to create a new  react App      :  npx  create-react-app  my-app
CMD to run app                      :  npm start
Custom cmd to run                   :  change in package.json   
                                       npm run my-app

1) PROJECT DIRECTORY STRUCTURE
````````````````````````````````
    package.json  :- It is the main configuration file of the app. Contains the info of application and all packages. Most imp file of project.
    It conatins all details of project, versions, dependencies etc.

    package-lock.json :- It is a description file Contains info of all the packages of node modules folder in a tree STRUCTURE. Contains version history and dependencies of all the used packages.

    .gitignore :- File related with git. It actually tells the GIT to ignore these specified files and folders  during commit.

    src :- Main folder of tha app which contains the source code of app.

    src/App.js :- File representing the app. A pre deault made component.

    src/App.test.js :- USed for writing unit test cases. testing purpose.

    src/index.js :- The most imp file of react app. It is actually the entry point of react app. It is the first file which runs on start.

    public :- Folder not related with react. mainly HTML content. Generally used for serving Static content ex. images media file etc.

    public/index.html :- It is the by default web page of react shown.
                        In it, there is a div with id='root'.
                        React injects the dynamic content inside this root only.

    node_modules :- It is the folder in which all the installed modules and packages are located.


2) COMPONENTS 
`````````````` 
    In REACT, a component is basically a JS function which returns some HTML code. It represents a Component of a web page.
    It is an independent piece of code that is defined once , and can be reused again and again.
    Its name should always start with Capital letter. It also has its state.
    return statement is must.

    Basic Example : Defining a header component and using it in app.

    Components/Header.js
       
        export function Header(){
            return (<h1> THIS IS HEADER </h1>);
        }

    App.js

        import Header from './Components/Header'

        function App(){
            return(<div>
                <Header />      //rendering a component
                <p>
                    Some content
                </p>
            </div>);
        }

    index.js 

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <React.StrictMode>
                <App />
            </React.StrictMode>
        );
 
    TYPES OF COMPONENTS
    ```````````````````
    Functional component :- A component defined by using a function.
                            Ex. 

                            function Header(){
                                return(
                                    <h1> HEADER </h1>
                                );
                            }
                            export default Header;    
                                 or   
                                 export {Header, AdminHeader, UserHeader}   to export multiple Components

    Class component :- A component defined by using Class.
                        Ex. 

                        import React from 'react';

                        class Footer extends React.Component{
                            render(){
                                return(
                                    <h1> THIS IS FOOTER </h1>
                                );
                            }
                        }

3) JSX (Javascript XML)
````````````````````````
    Its a powerfull syntax, which allows us to write HTML code in React with easy way.
    Without it we will have to do very tedious work Ex. 

        function Header(){
            return (
                React.createElement(h1,null, 'HEADER COMPONENT')
            );
        } 

        By using JSX, we not need to to above stuff.

         function Header(){
            return (
               <h1> HEADER COMPONENT</h1>
            );
        } 

        Rendering a component by JSX :- 

            root.render(
                <Header />
            );

    Displaying data in JSX : 

        function AdminHeader(){
            const admin = {
                name : "Mukul Mahajan",
                id : 1911, 
            }

            return(
                <div id="header">
                    <h2> THIS IS ADMIN HEADER </h2>
                    <h5>Admin {admin.id} : {admin.name}</h5>
                </div>
            );
        }

    Conditional Rendering in JSX : 
                                    let content;
                                    if (isLoggedIn) {
                                        content = <AdminPanel />;
                                    } else {
                                        content = <LoginForm />;
                                    }

                                    return (
                                        <div>
                                            {content}
                                        </div>
                                    );


                Recommended way :      return {isLoggedIn ? <AdminPanel /> : <LoginForm />};

4) Working of ReactJS
```````````````````````
    Whenever we perform any changes in the elements of DOM on any event, ideally entire DOM gets updated and is 
    rendered again. But, it is a very costly operation if we do it again and again. Here, React comes in picture.
    React maintains a lightweight version of actual(real) DOM called as Virtual DOM.
    So, when changes are made to the UI, they are first applied to the virtual DOM. React then calculates the most efficient
    way to update the actual DOM and applies only the necessary changes.

    Reconciliation :- React's diffing algorithm, called reconciliation, is responsible for efficiently updating the DOM.
    When, state of an element changes in the DOM, react first creates a new virtual DOM with the updated state of the respective 
    elements. Then it compares it with the previous virtual DOM, to find out the differences between them. 
    After, it is known to React about what portion has been changed, it applies just those specific changes to the Real DOM
    without re-rendering the entire document.


5) State in ReactJS
````````````````````
    A state is basically an object, which stores some data or informtion about the component. In layman terms, it represents the current
    condition of the component. Its just like a simple object holding some data, which can be updated in response to event handlers,
    server responses, prop changes or some programming logics.
    Whenever, the state of a component is changed/updated React re-renders the component on browser, which helps in creating dynamic 
    and interactive user interfaces.

    State is immutable. When the state object is updated, the changes are not done in the actual state object, inplace a new copy of state is initialised
    with the updated state values and it replaces the old object.

    State has to be first initialised, and then later on updated accordingly for a specific component. State can be used in both the ways :-

    (i) State in Functional Component :- useState hook is used to initialise a state in Functional component. It returns an array with
                                        two elements: the current state value and a function to update it.

        function Content(){
            let [data, setState] = useState("Hello I am Java Dev!");   // STATE INITIALISATION
    
            function update(){
                setState("Start ReactJS");     // UPDATING STATE
            }

            return (
                <div>
                    <h1>{data}</h1>
                    <br />
                    <button onClick={update}>
                        Click Me
                    </button>
                </div>
            );
        }

            Counter Example:

                let [data, setState] = useState(1);
        
                function update(){
                    setState(data+1);
                }

            Object example : 

                let [data, setState] = useState({
                                                id: 12712,
                                                name: "mukul",
                                                company: "Internshala",
                                                ctc : 5.4,
                                            });
            
                function update(){
                    const obj = {
                        id: 754,
                        name: "virat kohli",
                        company: "Entigrity",
                        ctc : 7.2,
                    };
                    setState(obj);
                }

    (ii) State in Class Component :- 

        class Content2 extends React.Component {
            constructor(){
                super();
                this.state = {
                    data : "Mukul",
                };
            }
            update(){
                this.setState({
                    data: "Bhopal",
                });
            }
            render(){
                return (
                    <div>
                        <h2>Content 2 is {this.state.data}  Class Component</h2>
                        <button onClick={this.update}>Click Me</button>
                    </div>
                );
            };
        }

6) Props 
``````````  
    Props are sometimes abbreviated as "Properties". It is basically very similar to passing arguments in a function.
    Prop is actally an object which holds some data, and is passed to the component while rendering.

    It is a mechanism of passing data from parent component to child component.
    To send props into a component, use the same syntax as HTML attributes:

        <Student name={"Mukul"} />

        function Student(props){
            return(
                <h1>
                    Hello {props.name}
                </h1>
            );
        }

    Example :--- 

        let student = {
            id:19,
            name: 'Mukul',
            age: 23
        }
        <Student  data={student} />

        function Student(props){
            let student = props.student;

            return(
                <h2>{student.id} {student.name} {student.age}</h2>
            );
        }

    React Props are read-only! You will get an error if you try to change their value. It can be changed only in the
    source component. The component in which it is passed, their we cannot modify it.

    Props in class component :-

    <Student name={'Mukul'} />

    class Student extends React.Component {
        render(){
            let name = this.props.name;
            return(
                <div>
                    <h2>Helllow {name}</h2>
                </div>
            );
        }
    }

    Passing function as Prop
    ````````````````````````  
    A function can also be passed as prop in a component. It can be helpfull when multiple components need to call a single 
    function at times. So, we can define it in parent component and pass to child components.

    App.js

    function print(){
        alert("Hello Mukul !");
    }

    return(
        <div>
            <Component data={print} />
        </div>
    );

    Component.js

        function Component(props){
            return(
                <button onClick={props.data}>CLICK ME</button>
            );
        }

7) Inputs
``````````
    (i) Get value of input field on change

        function print(input){
            console.log(input.target.value);
        }
        <input type='text' onChange={print} />

        For getting the input value on click of button, we can use state.

    (ii) Handling Form Data
    ````````````````````````````````
    export default function Form(){
        const [formData, setFormData] = useState({
            name:null,
            language:null,
            password:null,
            tnc:false,
        });

        function updateFormData(key,value){
            switch(key){
                case 'name':{
                    setFormData({
                        name : value,
                        language : formData.language,
                        password: formData.password,
                        tnc: formData.tnc,
                    });
                    break;
                }
                case 'language':{
                    setFormData({
                        name : formData.name,
                        language : value,
                        password: formData.password,
                        tnc: formData.tnc,
                    });
                    break;
                }
                case 'password':{
                    setFormData({
                        name : formData.name,
                        language : formData.language,
                        password: value,
                        tnc: formData.tnc,
                    });
                    break;
                }
                case 'tnc':{
                    setFormData({
                        name : formData.name,
                        language : formData.language,
                        password: formData.password,
                        tnc: value,
                    });
                    break;
                }
                default:
                    break;
            }
        }

        function submitForm(e){
            e.preventDefault();
            if(formData.tnc){
                alert(formData.name + ' ' + formData.language + ' ' + formData.password);
            }else{
                alert("Fill agree the TnC !!");
            }
        }

        return(
            <div>
                <h2>{formData.name}</h2>
                <h2>{formData.password}</h2>
                <h2>{formData.language}</h2>
                <h2>{formData.tnc}</h2>
                <form onSubmit={submitForm}>
                    <input type="text" placeholder="Name" value={formData.name} onChange={(e)=>updateFormData('name',e.target.value)}/>  <br /> <br />
                    <select value={formData.language} onChange={(e)=>updateFormData('language',e.target.value)}>
                        <option value="">--Select Language--</option>
                        <option value="Java">Java</option>
                        <option value="Python">Python</option>
                        <option value="Javascript">Javascript</option>
                    </select> <br /> <br />
                    <input type="password" placeholder="Password" value={formData.password} onChange={(e)=>updateFormData('password',e.target.value)} /> <br /> <br />
                    <input type="checkbox" value={formData.tnc}  onChange={(e)=>updateFormData('tnc',e.target.checked)} /> Agree Terms & Conditions <br /> <br />
                    <button >Submit</button>
                </form>
            </div>
        );
    }

    Input fields of a form can be handled by using multiple individual state objects.

        const [name, setName] = useState('');
        const [language, setLanguage] = useState('');
        const [tnc, setTnc] = useState(false);

        ex.   <input type="text" placeholder="Name" value={name} onChange={(e)=>setName(e.target.value)}/>

    
    (iii) Basic Form Validation  : - >    check    Login.js    file


8) LIFE CYCLE METHODS IN REACT_JS
```````````````````````````````````
    In React.js, lifecycle methods are methods that are called at different points in the lifecycle of a React component.
    These methods allow you to perform specific actions or logic at different stages, such as when a component is
    mounted, updated, or unmounted. 
    The entire lifecycle of a component is divided into 3 phases :- 
        Mounting, Updating and Unmounting.

    (i) Mounting :-  It means adding a component to the DOM. It has following life cycle methods :-

            constructor() : Used for initializing state and binding event handlers. Envoked as the first method when a 
                            component is mounted. The constructor() method is called with the props, as arguments, and
                            you should always start by calling the super(props) before anything else, this will initiate
                            the parent's constructor method and allows the component to inherit methods from its parent.

            getDerivedStateFromProps() : Method is called right before rendering the element(s) in the DOM. This is the
                                        natural place to set the state object based on the initial props.
                                        It takes state as an argument, and returns an object with changes to the state.
            
            render() :  It presents or renders the component in DOM. It is called when the component is mounted for the first 
                        time, and is called again Whenever the state of the component is changed.

            componentDidMount() : This method is called after the component has been completely rendered to the DOM.
                                Used for performing actions that require the DOM, such as calling API etc.
                                Define it inside the class to check it.           

    (ii) Updating :- A component is updated whenever there is a change in the component's state or prop.

            getDerivedStateFromProps() : 
            
            shouldComponentUpdate() : It basically asks whether to re render a component or not. It blocks the envoking of 
                                      render(). By default it returns false.
                                      We need to explicitly return true to continue the rendering process. By this, we can conditionally,
                                      decide whether to re-render a component or not.

            render() : Called when the state or prop of the component is updated to rerender it.

            componentDidUpdate(prevProps, prevState, snapshot) : It is envoked, whenever the state or prop of  component is updated. After the render()
    
    (iii) Unmounting :- The next phase in the lifecycle is when a component is removed from the DOM. It has only one method.

            componentWillUnmount() : It is called just before when the component is about to be removed from the DOM.


9) HOOKS
``````````
    Hooks are basically some functions which allow Functional components to use a variety of features of class components
    like state, lifecycle , pure components etc. It has following rules :-
        Hooks can only be called inside functional components.
        Hooks can only be called at the top level of a component.
        Hooks cannot be conditional

    They always start with name 'use'.  Ex- useState(), useEffect() etc. They cannot be used in class components.
    Also, we cannot define a function in React starting with 'use' because it is reserved for hooks.

    (i) useState() :- Used for implementing state in functional component. Takes initial state value as input and returns
                      the state object and updating function.

                        const [name,setName] = useState("Mukul");

                  IMPORTANT
    (ii) useEffect() :- Is used to perform side effects in functional components. Side effects refer to operations that
                        are not part of the component rendering but are necessary for tasks such as data fetching,
                        manual DOM manipulations, connection/disconnection, cleanup code etc.
                        useEffect accepts two arguments. The second argument is optional.

                        useEffect(<callback_function>, <dependency>)

                        callback_function is the effect which has to be performed, and dependency array is the list of dependencies
                        on whose change, the following effect will run. 

                        IMPORTANT :- 
                            By using this hook, we tell our React Component, that it need to do something after the render. The callback function
                            us the actually the 'effect', which needs to be performed.
                            Also, by defining the useEffect inside the component allows it to access state and props of the component.

                            By default, useEffect is envoked automatically after first render and also, when a state or prop is updated.
                        
                        let [count, setCount] = useState(0);
                        let [data, setData] = useState(100);

                        useEffect(()=>{
                            console.log("UseEffect Called !");
                        }, [data]);

                        <button onClick={()=>setCount(count+1)}> Click here </button>
                        <button onClick={()=>setData(data+1)}> Click here 2 </button>

                        In the above example, the useEffect will run only when, the {data} state is updated. We can pass all the states or Props
                        in the dependency array, on whose update the effect will run.


10) REACT - BOOTSTRAP
``````````````````````
    React has some inbuild components for Bootstrap.

    <Button></Button>
    <Container> <Row> <Col>
    <Stack>  etc


11) Rendering Lists and Keys
``````````````````````````````

    For iterating over a list or array in React, we Generally use map() function of JS.
    At every iteration, it receives each element of the list, from where it can be operated or directly returned.

    const newArray = array.map((currentValue, index, array) => {
                // Return the result of applying a function to each element
                // currentValue: the current element being processed in the array
                // index: the index of the current element
                // array: the array being mapped
            return /* transformed value based on currentValue, index, or array */;
    });

    const students = [
        {
            name : "mukul",
            email : "mukul@gmail.com",
            age: 23,
        },
        {
            name : "rohit",
            email : "rohit@gmail.com",
            age: 34,
        },
        {
            name : "virat",
            email : "virat@gmail.com",
            age: 34,
        },
    ];

    return(
        <div>
            <h3>Rendering Lists</h3>
            {
                students.map(function(student){
                    return(
                        <h5>{student.name} {student.email}</h5>
                    );
                })
            }
        </div>
    );

    Keys :-  It is always a good practice to include a 'key' prop in each rendered element of the list. It helps react to uniquely identify 
             each element during updating the DOM.

                return(
                    <div>
                        {
                            students.map(function(student, index){
                                return(
                                    <h5 key={index} >{student.name} {student.email}</h5>
                                );
                            })
                        }
                    </div>
                );


12) Using reusable component in map()
``````````````````````````````````````
    return(
        <div>
            {
                students.map(function(student, index){
                    return(
                        <div key={index}>
                            <Student data={student}/>
                        </div>
                    );
                })
            }
        </div>
    );

    -- Student.js

    function Student(props){

        const student = props.data;
        return(
            <div>
                <h4>{student.name} {student.email} {student.age}</h4>
            </div>
        );
    }


13) Fragments
````````````````
    In React, every component returned should have a wrapper element. But, in many cases it was useless. 
    Fragment is the new concept by which, we can wrap a child component without using an extra div or parent element.

    ex.  <div> cannot come inside <tr>

        return(
            <>
                <h4>Hello</h4>
                <h4>Bye</h4>
            </>
        );

        or 

        return(
            <React.Fragment>
                <h4>Hello</h4>
                <h4>Bye</h4>
            </React.Fragment>
        );


14) LIFTING STATE UP
```````````````````````
    Sending data from Child to Parent involves use of a function in parent component, which receives data from child.
    It is passed to child as a prop, where in child it is invoked with passing some arguments in it.

    >>>>>Parent
    import Child from './Child';
    import { useState } from 'react';

    function Parent(){
        const [name, setName] = useState("Mukul Parent");
    
        function parentFunction(data){
            setName(data);
        }
        return(
            <div>
                <h1>Parent Component {name}</h1>
                <Child data={parentFunction} />
            </div>
        );
    }

    >>>>>>> Child
    import { useState } from "react";

    function Child(props){
        const [name,setName] = useState("Mukul Child");
        return(
            <div>
                <h3>Child Component : {name} </h3>
                <button onClick={()=>props.data(name)}>Click Me</button>
            </div>
        );
    }

15) PURE COMPONENTS
`````````````````````
    Pure Component is a class in React. If we make a component by extending it,  it will restrict the re rendering of
    the component if the old state and new state to be set is same. It helps to optimize the performance as re rendering
    is a costly operation.
    To use it, just create the component by extending the  React.PureComponent class.

16) useMemo HOOK
`````````````````
    It is basically a Hook, whose aim is to improve the performance of the app. It prevents the useless envoking of a function.
    If a function depends only on stateA, but due to re-rendering, it will be called if any other state stateB is also changed.
    This call will be useless. So, useMemo prevents such calls.

    useMemo(function to memoize, [dependency array]);
    In dependency array, we specify the states or props, on which this function is dependent.

    function MemoHook(){
        const [state1,setState1] = useState(1);
        const [state2,setState2] = useState(10);

        const calculate = useMemo(()=>{
            console.log('calculating..........');
            return(state1 * 2);
        }, [state1]);

        return(
            <div>
                <h3>use Memo using S1 = {state1}</h3>
                <h3>use Memo using S2 = {state2}</h3>
                <h3>Product is  {calculate}</h3>
                <button onClick={()=>setState1(state1+1)}>Update State 1</button>
                <button onClick={()=>setState2(state2+10)}>Update state 2</button>
            </div>
        );
    }    

17) Ref and useRef Hook
`````````````````````````
    useRef Hook is used to perform DOM manipulations over an element without using state or props.
    Checkout RefHook.js

18) Controlled and Uncontrolled Components
```````````````````````````````````````````

    Controlled Components :- A component which is controlled by state or props.

    Uncontrolled Component :- A component which is controlled by UseREf  or directly by Javascript.

                           useRef or  DOM api.

19) HIGHER ORDER COMPONENT : it is a component which receives a component as a prop, and also returns a component.


            ------------  ROUTING  ------------
``````````````````````````````````````````
20) REACT ROUTER
`````````````````````````````````````````
    Its an important tool, which is used to handle routing in Reactjs.
    Firstly, wrap our app inside a router wrapper. 

    <BrowserRouter>
        <App />
    </BrowserRouter>

    Next creating pages :- 

        function Home() {
            return (
                <div>
                    <h1>HOME PAGE</h1>
                </div>
            );
        }
        export default Home;

        function About() {
            return (
                <div>
                    <h1>ABOUT PAGE</h1>
                </div>
            );
        }
        export default About;

    In App.js :

        return (
            <div className="App">
                <Routes>
                    <Route path="/" element={<Home />} />
                    <Route path="/about" element={<About />} />
                </Routes>
            </div>
        );


       ** Creating Links for different Routes :---

            function NavBar() {
                return(
                    <>
                        <Link to='/'>Home</Link>          // NavLink  can also be used
                        <Link to='/about'>About Us</Link>
                        <Link to='/services'>Services</Link>
                    </>
                );
            }


        <Route  path="/*" element={<Page404 />} />   // FOR 404 NOT FOUND ROUTER

        <Route  path="/*" element={<Navigate to='/' />} />   // REDIRECTION

        useNavigate() Hook :-  The useNavigate hook is also part of the react-router-dom library in React, and it's used
                               for programmatic navigation. It provides a function that allows you to navigate to a different location
                               in your application.

                               const navigate = useNavigate();

                               if(!login){
                                    navigate('/login');
                               }

21) PARAMS IN ROUTES
``````````````````````
    It can be implemented by useParams() hook.

    Routes.
        <Route path='/user/:name' />     //here :name is a dynamic parameter

    function User(){
        const {name} = useParams();
        return(
            <div>
                <h1> This is {name} page.</h1>
            </div>
        );
    }


    Query Params :    params in this form    user?id=10&city='bhopal'

    const [searchParams, setSearchParams] = useSearchParams();

    id = searchParams.get('id');
    city = searchParams.get('city');

    useLocation() Hook
    ```````````````````
    The useLocation hook allows you to access the current location object, which contains
    information about the current URL ,like   path, state, hash value etc.

    const data = useLocation();
    console.log(data);

        hash: ""
        key: "default"
        pathname: "/user/mukul/gurgaon"
        search: "?id=10"
        state: null

***********************************************************************************************************
**************************************************************************************************************


22) DEALING WITH API's
``````````````````````````
    In Reactjs, We can call for an API on network via 3 different ways : 
        i) fetch()
        ii) XMLhttpRequest (AJAX call)
        iii) Axios()

    fetch() function in JS
    ``````````````````````
    It is an inbuilt function of Js, by which we can fire a request to another server on the network.
    It returns a promise object, which needs to be resolved before use.


        Example :- 
        
            fetch(url).then((response)=>{
                response.json().then((result)=>{
                    console.log(result);
                });
            }).catch((error)=>{
                throw error;
            });


        function Get(){
            const [data, setData] = useState([]);

            useEffect(()=>{
                fetch('https://cat-fact.herokuapp.com/facts').then((response)=>{
                    response.json().then((result)=>{
                        setData(result);
                    });
                });
            }, []);
    
            return(
                <div>
                    <h2>Testing Get request</h2>
                    <table border={3} cellSpacing={5}>
                    {
                        data.map((item)=>{
                            return (<tr>
                                <td>{item._id}</td>
                                <td>{item.text}</td>
                                <td>{item.user}</td>
                            </tr>);
                        })
                    }
                    </table>
                </div>
            );
        }



